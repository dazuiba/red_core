package com.aptana.editor.dtd.parsing;

import java.util.ArrayList;
import com.aptana.editor.dtd.parsing.ast.*;
import beaver.*;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.parsing.IParseState;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "DTD.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class DTDParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9ojbdTy54KKnt#xUtSqCQII44qWI1D3I3EGGeX48OceA7O5xDWG6zW1Um6ne2Z$M50IhDW" +
		"Y8b4GArX12LtKKAo01R30yxTpx#IoTuc97$S#t$dDl3VpPdPczcO0AmCpa0OV0cY3jcY7zh" +
		"W4uz4H#yEcfsjKpsGSWlxeXEwO8Oz4hV4G7CH5zJWuhmdxYAZs59nXUij0Bzo6L9o8at0oJ" +
		"i6fE0sdOvJinR6u6KVZ6CGY7ZSY1jVX25mAFpfWFn7JTYf7EX5tUhqHvODmA2P5M8VXI4o9" +
		"i0x2OPWPOHqkg$0mUYC1UHYCV8p4yJW1ep46YUYCKfJ9vsP4XHY8SYJXO1IZ7vBH1Jcu1qD" +
		"mEFgWBpAH9MkHZLnJzm0KwLkKy2rwC7flHizZMc3IO6aSUg82bHnh1ix5vJWRv#D2N8q1c2" +
		"WRS22knKsu4brbFQfmFHx0nRW8wR8EHw6RrCjA#K9Mo7Bv3ETWACx2tJWEOt4cBi1bk08JS" +
		"0DknLMu1hVWTjo1QRXBvZFYTDo7Ut4$7kI8$SZY6BFv7haSJJvdie1z3wGdhWbFNxwLpRVF" +
		"v9YRQcj5zMHofqItEr7jFivXg3UB8#tEbUx1#Uh5kUl3DG3IsR8RPow5An7QWUvwkZiGfcq" +
		"ysoRoU$1wlUKoxelO2Al5lYEjRjn8wo3MZcLzotmFVkwkeTo3xjeEuPw9uNTdcPPn7560#G" +
		"1tbgkfJ1tZ3s6PrAqRODrzR#5dT9lHVKpz9WsMYXYpn8pLjHSIznVF#8cq5ZEwpHqQntmHT" +
		"rGQTtc2wRdKZ7RVhzX4I6Rz14QjKcyI8phyMVmoB1Chc1Qg5vWr6UOPJSQv#TR0fmkfSjTB" +
		"otDL5wekKgqc8yXIibD4$gBk8dl8th1uDMIvvbUgplVqkS1JhlEKwrLNgQvHNQ#wGNKEE0c" +
		"4YMKpKqjrY8$uIO2swLftKrZyF58MEHTMMw#jfR1jEzA6cStQHuFgRh95yrkRQT#HoLfgZ9" +
		"OxgSQgnZ7Phd7M4NV#9sXvYkhFP1Jh9cfvfBRjh9fCkDuMzusLGb9fN4nDKtzws7WwC9cgS" +
		"MQ6x5pt5UIVzMxT767ylzLXx6sKsXR4AW$Bz$oFuodtbAUfpbQjRaMi6jMwCDjOwFVpVyDd" +
		"MHJRaXQsdTUQlhWc6xLT#x0OgyFozIteiw6P#3kqJfBghA387lbJ$f3VPRViaftoc$mglyY" +
		"JyeHwkTjb1zbEji7po1fPRVG3yhwyAhNoYhmiBycByeBCa#VbENbMdg7lNV8EUPkyHvPu8v" +
		"aeFv4VvGUJtomVoOUoZBcbygby8X$BMx9O5icRyeRKoK9vNHR8QzhkQVAKoSqbDL8jS#Hx#" +
		"Kw#LVzMieLiDAKlrJgRFAxvJQI1VECPqTVaA$Cl37cCFChC6DuAB0BU0snYcTj0YAmco8Ql" +
		"4JayONAe9OpXdcovIXvjBaNqvrE3#7bV259epYM7fvtDKzT7$CGnPs0nsvSRx30QbzqpF4H" +
		"f8soUmpxU4XnYyqHsY8zt1eVOFEijdlPDCqmPh7UPVaP3D5#kO3yLV8zAzbM9uBbSnJhzbG" +
		"BQ2kXtxqi3gCF$1e9gsH4=");

	private DTDScanner _scanner;
	
	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	@Override
	public synchronized IParseNode parse(IParseState parseState) throws java.lang.Exception
	{
		// grab source
		char[] characters = parseState.getSource();

		// make sure we have some source
		String source = (characters != null) ? new String(characters) : "";

		// send source to the scanner
		this._scanner.setSource(source);

		// parse
		IParseNode result = (IParseNode) parse(this._scanner);
		
		// save reference to result
		parseState.setParseResult(result);
		
		return result;
	}

	public DTDParser() {
		super(PARSING_TABLES);


		this._scanner = new DTDScanner();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // DTD = Declarations.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final ArrayList _list_d = (ArrayList) _symbol_d.value;
					final beaver.Symbol[] d = _list_d == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_d.toArray(new beaver.Symbol[_list_d.size()]);
					
		return new DTDParseRootNode(d);
			}
			case 1: // DTD = 
			{
					
		return new DTDParseRootNode();
			}
			case 2: // Declarations = Declarations Declaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 3: // Declarations = Declaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 11: // MarkupDecl = PI.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					
		String content = p.substring(2, p.length() - 2);
		
		return new DTDProcessingInstructionNode(content);
			}
			case 13: // ElementDecl = ELEMENT NAME.n EMPTY GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDElementDeclarationNode(n);
			}
			case 14: // ElementDecl = ELEMENT NAME.n ANY GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDElementDeclarationNode(n);
			}
			case 15: // ElementDecl = ELEMENT NAME.n Mixed GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDElementDeclarationNode(n);
			}
			case 16: // ElementDecl = ELEMENT NAME.n Children GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDElementDeclarationNode(n);
			}
			case 17: // AttlistDecl = ATTLIST NAME.n GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDAttributeListDeclarationNode(n);
			}
			case 18: // AttlistDecl = ATTLIST NAME.n AttDefs GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDAttributeListDeclarationNode(n);
			}
			case 19: // AttDefs = AttDefs AttDef
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 20: // AttDefs = AttDef
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 23: // NotationDecl = NOTATION NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDNotationDeclarationNode(n);
			}
			case 24: // NotationDecl = NOTATION NAME.n PublicID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDNotationDeclarationNode(n);
			}
			case 26: // GEDecl = ENTITY NAME.n STRING GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDGEntityDeclarationNode(n);
			}
			case 27: // GEDecl = ENTITY NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDGEntityDeclarationNode(n);
			}
			case 28: // GEDecl = ENTITY NAME.n ExternalID NDataDecl GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
		return new DTDGEntityDeclarationNode(n);
			}
			case 29: // PEDecl = ENTITY PERCENT NAME.n STRING.s GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					
		String value = s.substring(1, s.length() - 1);
		this._scanner.register(n, value);
		
		return new DTDPEntityDeclarationNode(n);
			}
			case 30: // PEDecl = ENTITY PERCENT NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					
		return new DTDPEntityDeclarationNode(n);
			}
			case 37: // Names = Names PIPE NAME
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 38: // Names = NAME
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 88: // NmTokens = NmTokens NMTOKEN
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 89: // NmTokens = NMTOKEN
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 4: // Declaration = MarkupDecl
			case 5: // Declaration = PE_REF
			case 6: // Declaration = ConditionalSect
			case 7: // MarkupDecl = ElementDecl
			case 8: // MarkupDecl = AttlistDecl
			case 9: // MarkupDecl = EntityDecl
			case 10: // MarkupDecl = NotationDecl
			case 12: // MarkupDecl = COMMENT
			case 21: // EntityDecl = GEDecl
			case 22: // EntityDecl = PEDecl
			case 39: // Children = Choice
			case 43: // Children = Seq
			case 47: // AttType = StringType
			case 48: // AttType = TokenizedType
			case 49: // AttType = EnumeratedType
			case 50: // DefaultDecl = REQUIRED
			case 51: // DefaultDecl = IMPLIED
			case 52: // DefaultDecl = STRING
			case 61: // StringType = CDATA_TYPE
			case 62: // TokenizedType = ID_TYPE
			case 63: // TokenizedType = IDREF_TYPE
			case 64: // TokenizedType = IDREFS_TYPE
			case 65: // TokenizedType = ENTITY_TYPE
			case 66: // TokenizedType = ENTITIES_TYPE
			case 67: // TokenizedType = NMTOKEN_TYPE
			case 68: // TokenizedType = NMTOKENS_TYPE
			case 69: // EnumeratedType = NotationType
			case 70: // EnumeratedType = Enumeration
			case 72: // Cp = NAME
			case 76: // Cp = Choice
			case 80: // Cp = Seq
			case 90: // ConditionalSect = IncludeSect
			case 91: // ConditionalSect = IgnoreSect
			{
				return _symbols[offset + 1];
			}
			case 31: // ExternalID = SYSTEM STRING
			case 33: // PublicID = PUBLIC STRING
			case 40: // Children = Choice QUESTION
			case 41: // Children = Choice STAR
			case 42: // Children = Choice PLUS
			case 44: // Children = Seq QUESTION
			case 45: // Children = Seq STAR
			case 46: // Children = Seq PLUS
			case 53: // DefaultDecl = FIXED STRING
			case 56: // ChoiceCps = PIPE Cp
			case 60: // SeqCps = COMMA Cp
			case 71: // NDataDecl = NDATA NAME
			case 73: // Cp = NAME QUESTION
			case 74: // Cp = NAME STAR
			case 75: // Cp = NAME PLUS
			case 77: // Cp = Choice QUESTION
			case 78: // Cp = Choice STAR
			case 79: // Cp = Choice PLUS
			case 81: // Cp = Seq QUESTION
			case 82: // Cp = Seq STAR
			case 83: // Cp = Seq PLUS
			{
				return _symbols[offset + 2];
			}
			case 25: // AttDef = NAME AttType DefaultDecl
			case 32: // ExternalID = PUBLIC STRING STRING
			case 36: // Mixed = LPAREN PCDATA RPAREN
			case 55: // ChoiceCps = ChoiceCps PIPE Cp
			case 57: // Seq = LPAREN Cp RPAREN
			case 59: // SeqCps = SeqCps COMMA Cp
			case 86: // Enumeration = LPAREN NMTOKEN RPAREN
			{
				return _symbols[offset + 3];
			}
			case 34: // Mixed = LPAREN PCDATA RPAREN STAR
			case 54: // Choice = LPAREN Cp ChoiceCps RPAREN
			case 58: // Seq = LPAREN Cp SeqCps RPAREN
			case 84: // NotationType = NOTATION_TYPE LPAREN NAME RPAREN
			case 87: // Enumeration = LPAREN NMTOKEN NmTokens RPAREN
			case 92: // IncludeSect = SECTION_START INCLUDE LBRACKET SECTION_END
			case 94: // IgnoreSect = SECTION_START IGNORE LBRACKET SECTION_END
			{
				return _symbols[offset + 4];
			}
			case 35: // Mixed = LPAREN PCDATA Names RPAREN STAR
			case 85: // NotationType = NOTATION_TYPE LPAREN NAME Names RPAREN
			case 93: // IncludeSect = SECTION_START INCLUDE LBRACKET Declarations SECTION_END
			case 95: // IgnoreSect = SECTION_START IGNORE LBRACKET Declarations SECTION_END
			{
				return _symbols[offset + 5];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
