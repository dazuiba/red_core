package com.aptana.editor.dtd.parsing;

import java.util.ArrayList;
import com.aptana.editor.dtd.parsing.ast.*;
import beaver.*;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.parsing.IParseState;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "DTD.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class DTDParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oTbebV5LKKntypxpt5mYSWYBjPBhX48g8WMn2OW9POQMQfxOksMrQQIrbfgPN#3sLgMbO" +
		"ckMCkcRPehcHQkMMPcLcPwEatznri68O4vds#ypltd7lklU$EcNSVOBN6RCGWY4PeZ2WqmM" +
		"Lu00#YASAmCLj#yOqyYxReX7wCl#KRVnC1nFb60XXJYx#lhpyJjw4dhaOAud4LiZ44fHYAc" +
		"t0pRi4m39SB6cs1hfY8PdWAkNW88LoEQ16DfJFJ4wlHpi0pDNpZy5mDtoDueuPl0EOYqSmq" +
		"63VWHjoA4JfpCVghrGfPQYKX1zsHXWGyZslG3JsGYfb8HY#qH6$qGIoQemGlOI2Aq1wFqRe" +
		"IhT6PLXjCPNOIhc1sch6wg5M8FEhzrElOEn$jC1ftu2xSWoTa0yPZ4hDVb5#P#JJce0Fkmx" +
		"ro0XrnBGfmFGRXTep4ADoDEp4MZ#CLF8n7CG5FOWecOnfUm7IyB1zW1aTw3QzY5bxdUYskE" +
		"8KhJkMQq$Zq#d6VC$Xzarat$f4mltakuuFgcPdCol3tXtpzCQpE7cQtRUvm8fz#9#vV5rP8" +
		"4lUxE#2A$bTnpfDiUZ4Myebvsuci0wylqyTNwEFBeoyoqm0#0UTP5sixm9aZLl2YPT4Airt" +
		"0Q9Zr4M$U64TjSs$52kd0okd8fnzYPSKoeusnGknXyUEyuK6FPLEpZ5giX6psZNnYwGdGby" +
		"1wiTc$7UimpFSvJiVAOeKvyI1pIkYrs6h9cCstCC0Ti5c5jl56xfaQ0#PDXRb6aN6ENH$qM" +
		"aowQRjKTOngkUeoyYM99h#JpUGuEKlEkSRB8TlKtgcwq6VU9PxsKazxb#fOrNsg5Qe7L2l9" +
		"GRKFkV9JoGAVUSzxVNM5rmLmytaTqVPXrTFagDh7Qi#tGhpjfpRMTfHgKBK9RoTqdBta31c" +
		"lxScglv4ozetMzWxD3Ql6a5ZIZCIHvdIkfYPel8LhFG7UPkWuSwly8hATL3PmZoRKeKzdik" +
		"XI$RY6$QwSFWrPZ#RcUzfJLAUhpdJ5vgkMktoZoQg6pd#9jMtqyPNLCRUqFdDnFwlUcIZN6" +
		"DjTzjOwp5dnF#EVr3xnglCY8kVbdFmZP#Ll#Kl#b3FoXvoMHR9Ge$mraLE4bIqduRdaPpbk" +
		"z7joKFR9NjaZksMN$2J7vAWSaSDoI7wK7nZzZl3jac$90L9XydQIRsI7iRV9EbahQsYjbaz" +
		"blPJBAbafA#GJAPFbyh4iau$aGvrtANdVME#H9R9OtkLxyRLyfN7#5ieNP9DfRLJl0lAEsb" +
		"l9vsIBvnjzHZPBfR7daxTfZE09RX7mpBQ9PVuDLD6h5deZM8q2GyYSQTa6YwUTW#sYUhidS" +
		"tBODuUsSr8wPsGkDTUSvSufQRkm#BiQ846URZQn#2yXGXfz3bdwlpD2YFyV8ZWdLYPZXTGy" +
		"zgyYlnespswBftVj35ISyx28SnHnx6AEMqoxXBuInbAKTFhI6S#WPb07$mkxky8p");

	private DTDScanner _scanner;
	
	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	@Override
	public synchronized IParseNode parse(IParseState parseState) throws java.lang.Exception
	{
		// grab source
		char[] characters = parseState.getSource();

		// make sure we have some source
		String source = (characters != null) ? new String(characters) : "";

		// send source to the scanner
		this._scanner.setSource(source);

		// parse
		IParseNode result = (IParseNode) parse(this._scanner);
		
		// save reference to result
		parseState.setParseResult(result);
		
		return result;
	}
	
	protected void addChildren(IParseNode node, ArrayList children)
	{
		if (node != null && children != null)
		{
			for (Object child : children)
			{
				if (node instanceof IParseNode)
				{
					node.addChild((IParseNode) child);
				}
			}
		}
	}

	public DTDParser() {
		super(PARSING_TABLES);


		this._scanner = new DTDScanner();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // DTD = Declarations.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final ArrayList _list_d = (ArrayList) _symbol_d.value;
					final beaver.Symbol[] d = _list_d == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_d.toArray(new beaver.Symbol[_list_d.size()]);
					
		return new DTDParseRootNode(d);
			}
			case 1: // DTD = 
			{
					
		return new DTDParseRootNode();
			}
			case 2: // Declarations = Declarations Declaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 3: // Declarations = Declaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 11: // MarkupDecl = PI.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					
		String content = p.substring(2, p.length() - 2);
		
		return new DTDProcessingInstructionNode(content);
			}
			case 13: // ElementDecl = ELEMENT NAME.n EMPTY GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(new DTDEmptyNode());
			
			return decl;
			}
			case 14: // ElementDecl = ELEMENT NAME.n ANY GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(new DTDAnyNode());
			
			return decl;
			}
			case 15: // ElementDecl = ELEMENT NAME.n Mixed.m GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final DTDNode m = (DTDNode) _symbol_m.value;
					
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(m);
			
			return decl;
			}
			case 16: // ElementDecl = ELEMENT NAME.n Children.c GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(c);
			
			return decl;
			}
			case 17: // Mixed = LPAREN PCDATA RPAREN STAR
			{
					
			DTDPCDataNode data = new DTDPCDataNode();
			DTDZeroOrMoreNode zom = new DTDZeroOrMoreNode();
			
			zom.addChild(data);
			
			return zom;
			}
			case 18: // Mixed = LPAREN PCDATA Names.n RPAREN STAR
			{
					final Symbol _symbol_n = _symbols[offset + 3];
					final ArrayList n = (ArrayList) _symbol_n.value;
					
			DTDPCDataNode data = new DTDPCDataNode();
			DTDZeroOrMoreNode zom = new DTDZeroOrMoreNode();
			
			zom.addChild(data);
			this.addChildren(zom, n);
			
			return zom;
			}
			case 19: // Mixed = LPAREN PCDATA RPAREN
			{
					
			return new DTDPCDataNode();
			}
			case 20: // Names = Names PIPE NAME
			{
					
			String name = (String) _symbols[offset + 3].value;
			DTDElementNode element = new DTDElementNode(name);
			((ArrayList) _symbols[offset + 1].value).add(element);
			
			return _symbols[offset + 1];
			}
			case 21: // Names = NAME
			{
					
			ArrayList lst = new ArrayList();
			String name = (String) _symbols[offset + 1].value;
			DTDElementNode element = new DTDElementNode(name);
			
			lst.add(element);
			
			return new Symbol(lst);
			}
			case 23: // Children = Choice.c QUESTION
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			DTDOptionalNode result = new DTDOptionalNode();
			
			result.addChild(c);
			
			return result;
			}
			case 24: // Children = Choice.c STAR
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			DTDZeroOrMoreNode result = new DTDZeroOrMoreNode();
			
			result.addChild(c);
			
			return result;
			}
			case 25: // Children = Choice.c PLUS
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			DTDOneOrMoreNode result = new DTDOneOrMoreNode();
			
			result.addChild(c);
			
			return result;
			}
			case 27: // Children = Seq.s QUESTION
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final DTDNode s = (DTDNode) _symbol_s.value;
					
			DTDOptionalNode result = new DTDOptionalNode();
			
			result.addChild(s);
			
			return result;
			}
			case 28: // Children = Seq.s STAR
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final DTDNode s = (DTDNode) _symbol_s.value;
					
			DTDZeroOrMoreNode result = new DTDZeroOrMoreNode();
			
			result.addChild(s);
			
			return result;
			}
			case 29: // Children = Seq.s PLUS
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final DTDNode s = (DTDNode) _symbol_s.value;
					
			DTDOneOrMoreNode result = new DTDOneOrMoreNode();
			
			result.addChild(s);
			
			return result;
			}
			case 30: // Choice = LPAREN Cp.c ChoiceCps RPAREN
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			ArrayList cps = (ArrayList) _symbols[offset + 3].value;
			DTDOrExpressionNode result = new DTDOrExpressionNode();

			// pre-pend leading cp			
			cps.add(0, c);
			
			// add all children to or-expr
			this.addChildren(result, cps);
			
			return result;
			}
			case 31: // ChoiceCps = ChoiceCps PIPE Cp.c
			{
					final Symbol _symbol_c = _symbols[offset + 3];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			((ArrayList) _symbols[offset + 1].value).add(c);
			
			return _symbols[offset + 1];
			}
			case 32: // ChoiceCps = PIPE Cp
			{
					
			ArrayList lst = new ArrayList();
			
			lst.add(_symbols[offset + 2]);
			
			return new Symbol(lst);
			}
			case 33: // Seq = LPAREN Cp.c RPAREN
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			return c;
			}
			case 34: // Seq = LPAREN Cp.c SeqCps.l RPAREN
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final DTDNode c = (DTDNode) _symbol_c.value;
					final Symbol l = _symbols[offset + 3];
					
			ArrayList cps = (ArrayList) _symbols[offset + 3].value;
			DTDAndExpressionNode result = new DTDAndExpressionNode();

			// pre-pend leading cp			
			cps.add(0, c);
			
			// add all children to or-expr
			this.addChildren(result, cps);
			
			return result;
			}
			case 35: // SeqCps = SeqCps.l COMMA Cp.c
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 3];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			((ArrayList) _symbols[offset + 1].value).add(c);
			
			return _symbols[offset + 1];
			}
			case 36: // SeqCps = COMMA Cp.c
			{
					final Symbol _symbol_c = _symbols[offset + 2];
					final DTDNode c = (DTDNode) _symbol_c.value;
					
			ArrayList lst = new ArrayList();
			
			lst.add(_symbols[offset + 2]);
			
			return new Symbol(lst);
			}
			case 37: // Cp = NAME.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			return new DTDElementNode(n);
			}
			case 38: // Cp = NAME.n QUESTION
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			DTDOptionalNode node = new DTDOptionalNode();
			
			node.addChild(new DTDElementNode(n));
			}
			case 39: // Cp = NAME.n STAR
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			DTDZeroOrMoreNode node = new DTDZeroOrMoreNode();
			
			node.addChild(new DTDElementNode(n));
			}
			case 40: // Cp = NAME.n PLUS
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					
			DTDOneOrMoreNode node = new DTDOneOrMoreNode();
			
			node.addChild(new DTDElementNode(n));
			}
			case 42: // AttlistDecl = ATTLIST NAME.n GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDAttListDeclNode(n);
			}
			case 43: // AttlistDecl = ATTLIST NAME.n AttDefs GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDAttListDeclNode(n);
			}
			case 44: // AttDefs = AttDefs AttDef
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 45: // AttDefs = AttDef
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 48: // NotationDecl = NOTATION NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDNotationDeclNode(n);
			}
			case 49: // NotationDecl = NOTATION NAME.n PublicID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDNotationDeclNode(n);
			}
			case 51: // GEDecl = ENTITY NAME.n STRING GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDGeneralEntityDeclNode(n);
			}
			case 52: // GEDecl = ENTITY NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDGeneralEntityDeclNode(n);
			}
			case 53: // GEDecl = ENTITY NAME.n ExternalID NDataDecl GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					
			return new DTDGeneralEntityDeclNode(n);
			}
			case 54: // PEDecl = ENTITY PERCENT NAME.n STRING.s GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					
			String value = s.substring(1, s.length() - 1);
			this._scanner.register(n, value);
			
			return new DTDParsedEntityDeclNode(n);
			}
			case 55: // PEDecl = ENTITY PERCENT NAME.n ExternalID GREATER_THAN
			{
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					
			return new DTDParsedEntityDeclNode(n);
			}
			case 81: // NmTokens = NmTokens NMTOKEN
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 82: // NmTokens = NMTOKEN
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 4: // Declaration = MarkupDecl
			case 5: // Declaration = PE_REF
			case 6: // Declaration = ConditionalSect
			case 7: // MarkupDecl = ElementDecl
			case 8: // MarkupDecl = AttlistDecl
			case 9: // MarkupDecl = EntityDecl
			case 10: // MarkupDecl = NotationDecl
			case 12: // MarkupDecl = COMMENT
			case 22: // Children = Choice
			case 26: // Children = Seq
			case 41: // Cp = Children
			case 46: // EntityDecl = GEDecl
			case 47: // EntityDecl = PEDecl
			case 59: // AttType = StringType
			case 60: // AttType = TokenizedType
			case 61: // AttType = EnumeratedType
			case 62: // DefaultDecl = REQUIRED
			case 63: // DefaultDecl = IMPLIED
			case 64: // DefaultDecl = STRING
			case 66: // StringType = CDATA_TYPE
			case 67: // TokenizedType = ID_TYPE
			case 68: // TokenizedType = IDREF_TYPE
			case 69: // TokenizedType = IDREFS_TYPE
			case 70: // TokenizedType = ENTITY_TYPE
			case 71: // TokenizedType = ENTITIES_TYPE
			case 72: // TokenizedType = NMTOKEN_TYPE
			case 73: // TokenizedType = NMTOKENS_TYPE
			case 74: // EnumeratedType = NotationType
			case 75: // EnumeratedType = Enumeration
			case 83: // ConditionalSect = IncludeSect
			case 84: // ConditionalSect = IgnoreSect
			{
				return _symbols[offset + 1];
			}
			case 56: // ExternalID = SYSTEM STRING
			case 58: // PublicID = PUBLIC STRING
			case 65: // DefaultDecl = FIXED STRING
			case 76: // NDataDecl = NDATA NAME
			{
				return _symbols[offset + 2];
			}
			case 50: // AttDef = NAME AttType DefaultDecl
			case 57: // ExternalID = PUBLIC STRING STRING
			case 79: // Enumeration = LPAREN NMTOKEN RPAREN
			{
				return _symbols[offset + 3];
			}
			case 77: // NotationType = NOTATION_TYPE LPAREN NAME RPAREN
			case 80: // Enumeration = LPAREN NMTOKEN NmTokens RPAREN
			case 85: // IncludeSect = SECTION_START INCLUDE LBRACKET SECTION_END
			case 87: // IgnoreSect = SECTION_START IGNORE LBRACKET SECTION_END
			{
				return _symbols[offset + 4];
			}
			case 78: // NotationType = NOTATION_TYPE LPAREN NAME Names RPAREN
			case 86: // IncludeSect = SECTION_START INCLUDE LBRACKET Declarations SECTION_END
			case 88: // IgnoreSect = SECTION_START IGNORE LBRACKET Declarations SECTION_END
			{
				return _symbols[offset + 5];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
