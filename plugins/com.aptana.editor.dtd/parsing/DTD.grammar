// java -jar beaver.jar -T -w DTD.grammar
%package "com.aptana.editor.dtd.parsing";

%class "DTDParser";

%import "com.aptana.editor.dtd.parsing.ast.*";
%import "com.aptana.parsing.IParseState";
%import "com.aptana.parsing.IParser";
%import "com.aptana.parsing.ast.IParseNode";

%implements "IParser";

%embed {:
	private DTDScanner _scanner;
	
	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	@Override
	public synchronized IParseNode parse(IParseState parseState) throws java.lang.Exception
	{
		// grab source
		char[] characters = parseState.getSource();

		// make sure we have some source
		String source = (characters != null) ? new String(characters) : "";

		// send source to the scanner
		this._scanner.setSource(source);

		// parse
		IParseNode result = (IParseNode) parse(this._scanner);
		
		// save reference to result
		parseState.setParseResult(result);
		
		return result;
	}
	
	protected void addChildren(IParseNode node, ArrayList children)
	{
		if (node != null && children != null)
		{
			for (Object child : children)
			{
				if (node instanceof IParseNode)
				{
					node.addChild((IParseNode) child);
				}
			}
		}
	}
:};

%init {:
		this._scanner = new DTDScanner();
:};

%terminals ELEMENT, GREATER_THAN, ATTLIST, NOTATION, PI, EMPTY, ANY;
%terminals ENTITY, SYSTEM, PUBLIC, PCDATA, LPAREN, PIPE, RPAREN, QUESTION;
%terminals STAR, PLUS, FIXED, IMPLIED, REQUIRED, COMMA, CDATA_TYPE, ID_TYPE, IDREF_TYPE;
%terminals IDREFS_TYPE, ENTITY_TYPE, ENTITIES_TYPE, NMTOKEN_TYPE, NMTOKENS_TYPE, NDATA;
%terminals NOTATION_TYPE, PE_REF, NAME, PERCENT, STRING, LBRACKET;
%terminals COMMENT, NMTOKEN, SECTION_START, SECTION_END, IGNORE, INCLUDE;

%typeof NAME, PI, STRING = "String";
%typeof Mixed, Cp, Children, Choice, Seq = "DTDNode";
%typeof Names = "ArrayList";

%goal DTD;

// 0

DTD
	=	Declarations.d
	{:
		return new DTDParseRootNode(d);
	:}
	|
	{:
		return new DTDParseRootNode();
	:}
	;

// 1

Declarations
	=	Declarations Declaration
	|	Declaration
	;

Declaration
	=	MarkupDecl
	|	PE_REF
	|	ConditionalSect
	;

// 2

MarkupDecl
	=	ElementDecl
	|	AttlistDecl
	|	EntityDecl
	|	NotationDecl
	|	PI.p
	{:
		String content = p.substring(2, p.length() - 2);
		
		return new DTDProcessingInstructionNode(content);
	:}
	|	COMMENT
	;

// Element declaration

ElementDecl
	=	ELEMENT NAME.n EMPTY GREATER_THAN
		{:
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(new DTDEmptyNode());
			
			return decl;
		:}
	|	ELEMENT NAME.n ANY GREATER_THAN
		{:
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(new DTDAnyNode());
			
			return decl;
		:}
	|	ELEMENT NAME.n Mixed.m GREATER_THAN
		{:
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(m);
			
			return decl;
		:}
	|	ELEMENT NAME.n Children.c GREATER_THAN
		{:
			DTDNode decl = new DTDElementDeclNode(n);
			
			decl.addChild(c);
			
			return decl;
		:}
	;

Mixed
	=	LPAREN PCDATA RPAREN STAR
		{:
			DTDPCDataNode data = new DTDPCDataNode();
			DTDZeroOrMoreNode zom = new DTDZeroOrMoreNode();
			
			zom.addChild(data);
			
			return zom;
		:}
	|	LPAREN PCDATA Names.n RPAREN STAR
		{:
			DTDPCDataNode data = new DTDPCDataNode();
			DTDZeroOrMoreNode zom = new DTDZeroOrMoreNode();
			
			zom.addChild(data);
			this.addChildren(zom, n);
			
			return zom;
		:}
	|	LPAREN PCDATA RPAREN
		{:
			return new DTDPCDataNode();
		:}
	;
	
Names
	=	Names PIPE NAME
		{:
			String name = (String) _symbols[offset + 3].value;
			DTDElementNode element = new DTDElementNode(name);
			((ArrayList) _symbols[offset + 1].value).add(element);
			
			return _symbols[offset + 1];
		:}
	|	NAME
		{:
			ArrayList lst = new ArrayList();
			String name = (String) _symbols[offset + 1].value;
			DTDElementNode element = new DTDElementNode(name);
			
			lst.add(element);
			
			return new Symbol(lst);
		:}
	;

Children
	=	Choice
	|	Choice.c QUESTION
		{:
			DTDOptionalNode result = new DTDOptionalNode();
			
			result.addChild(c);
			
			return result;
		:}
	|	Choice.c STAR
		{:
			DTDZeroOrMoreNode result = new DTDZeroOrMoreNode();
			
			result.addChild(c);
			
			return result;
		:}
	|	Choice.c PLUS
		{:
			DTDOneOrMoreNode result = new DTDOneOrMoreNode();
			
			result.addChild(c);
			
			return result;
		:}
	|	Seq
	|	Seq.s QUESTION
		{:
			DTDOptionalNode result = new DTDOptionalNode();
			
			result.addChild(s);
			
			return result;
		:}
	|	Seq.s STAR
		{:
			DTDZeroOrMoreNode result = new DTDZeroOrMoreNode();
			
			result.addChild(s);
			
			return result;
		:}
	|	Seq.s PLUS
		{:
			DTDOneOrMoreNode result = new DTDOneOrMoreNode();
			
			result.addChild(s);
			
			return result;
		:}
	;

Choice
	=	LPAREN Cp.c ChoiceCps RPAREN
		{:
			ArrayList cps = (ArrayList) _symbols[offset + 3].value;
			DTDOrExpressionNode result = new DTDOrExpressionNode();

			// pre-pend leading cp			
			cps.add(0, c);
			
			// add all children to or-expr
			this.addChildren(result, cps);
			
			return result;
		:}
	;

ChoiceCps
	=	ChoiceCps PIPE Cp.c
		{:
			((ArrayList) _symbols[offset + 1].value).add(c);
			
			return _symbols[offset + 1];
		:}
	|	PIPE Cp
		{:
			ArrayList lst = new ArrayList();
			
			lst.add(_symbols[offset + 2]);
			
			return new Symbol(lst);
		:}
	;

Seq
	=	LPAREN Cp.c RPAREN
		{:
			return c;
		:}
	|	LPAREN Cp.c SeqCps.l RPAREN
		{:
			ArrayList cps = (ArrayList) _symbols[offset + 3].value;
			DTDAndExpressionNode result = new DTDAndExpressionNode();

			// pre-pend leading cp			
			cps.add(0, c);
			
			// add all children to or-expr
			this.addChildren(result, cps);
			
			return result;
		:}
	;
	
SeqCps
	=	SeqCps.l COMMA Cp.c
		{:
			((ArrayList) _symbols[offset + 1].value).add(c);
			
			return _symbols[offset + 1];
		:}
	|	COMMA Cp.c
		{:
			ArrayList lst = new ArrayList();
			
			lst.add(_symbols[offset + 2]);
			
			return new Symbol(lst);
		:}
	;

Cp
	=	NAME.n
		{:
			return new DTDElementNode(n);
		:}
	|	NAME.n QUESTION
		{:
			DTDOptionalNode node = new DTDOptionalNode();
			
			node.addChild(new DTDElementNode(n));
		:}
	|	NAME.n STAR
		{:
			DTDZeroOrMoreNode node = new DTDZeroOrMoreNode();
			
			node.addChild(new DTDElementNode(n));
		:}
	|	NAME.n PLUS
		{:
			DTDOneOrMoreNode node = new DTDOneOrMoreNode();
			
			node.addChild(new DTDElementNode(n));
		:}
	|	Children
	;

// Attribute declaration

AttlistDecl
	=	ATTLIST NAME.n GREATER_THAN
		{:
			return new DTDAttListDeclNode(n);
		:}
	|	ATTLIST NAME.n AttDefs GREATER_THAN
		{:
			return new DTDAttListDeclNode(n);
		:}
	;
	
AttDefs
	=	AttDefs AttDef
	|	AttDef
	;

EntityDecl
	=	GEDecl
	|	PEDecl
	;

NotationDecl
	=	NOTATION NAME.n ExternalID GREATER_THAN
		{:
			return new DTDNotationDeclNode(n);
		:}
	|	NOTATION NAME.n PublicID GREATER_THAN
		{:
			return new DTDNotationDeclNode(n);
		:}
	;

// 4

AttDef
	=	NAME AttType DefaultDecl
	;
	
GEDecl
	=	ENTITY NAME.n STRING GREATER_THAN
		{:
			return new DTDGeneralEntityDeclNode(n);
		:}
	|	ENTITY NAME.n ExternalID GREATER_THAN
		{:
			return new DTDGeneralEntityDeclNode(n);
		:}
	|	ENTITY NAME.n ExternalID NDataDecl GREATER_THAN
		{:
			return new DTDGeneralEntityDeclNode(n);
		:}
	;

PEDecl
	=	ENTITY PERCENT NAME.n STRING.s GREATER_THAN
		{:
			String value = s.substring(1, s.length() - 1);
			this._scanner.register(n, value);
			
			return new DTDParsedEntityDeclNode(n);
		:}
	|	ENTITY PERCENT NAME.n ExternalID GREATER_THAN
		{:
			return new DTDParsedEntityDeclNode(n);
		:}
	;

ExternalID
	=	SYSTEM STRING
	|	PUBLIC STRING STRING
	;

PublicID
	=	PUBLIC STRING
	;

// 5

AttType
	=	StringType
	|	TokenizedType
	|	EnumeratedType
	;

DefaultDecl
	=	REQUIRED
	|	IMPLIED
	|	STRING
	|	FIXED STRING
	;

// 6

StringType
	=	CDATA_TYPE
	;

TokenizedType
	=	ID_TYPE
	|	IDREF_TYPE
	|	IDREFS_TYPE
	|	ENTITY_TYPE
	|	ENTITIES_TYPE
	|	NMTOKEN_TYPE
	|	NMTOKENS_TYPE
	;
	
EnumeratedType
	=	NotationType
	|	Enumeration
	;
	
NDataDecl
	=	NDATA NAME
	;

// 7

NotationType
	=	NOTATION_TYPE LPAREN NAME RPAREN
	|	NOTATION_TYPE LPAREN NAME Names RPAREN
	;

Enumeration
	=	LPAREN NMTOKEN RPAREN
	|	LPAREN NMTOKEN NmTokens RPAREN
	;

NmTokens
	=	NmTokens NMTOKEN
	|	NMTOKEN
	;

// misc

ConditionalSect
	=	IncludeSect
	|	IgnoreSect
	;

IncludeSect
 	=	SECTION_START INCLUDE LBRACKET SECTION_END
 	|	SECTION_START INCLUDE LBRACKET Declarations SECTION_END
	;

IgnoreSect
	=	SECTION_START IGNORE LBRACKET SECTION_END
	|	SECTION_START IGNORE LBRACKET Declarations SECTION_END
	;
