// java -jar beaver.jar -T -w DTD.grammar
%package "com.aptana.editor.dtd.parsing";

%class "DTDParser";

%import "com.aptana.editor.dtd.parsing.ast.*";
%import "com.aptana.parsing.IParseState";
%import "com.aptana.parsing.IParser";
%import "com.aptana.parsing.ast.IParseNode";

%implements "IParser";

%embed {:
	private DTDScanner _scanner;
	
	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	@Override
	public synchronized IParseNode parse(IParseState parseState) throws java.lang.Exception
	{
		// grab source
		char[] characters = parseState.getSource();

		// make sure we have some source
		String source = (characters != null) ? new String(characters) : "";

		// send source to the scanner
		this._scanner.setSource(source);

		// parse
		IParseNode result = (IParseNode) parse(this._scanner);
		
		// save reference to result
		parseState.setParseResult(result);
		
		return result;
	}
:};

%init {:
		this._scanner = new DTDScanner();
:};

%terminals ELEMENT, GREATER_THAN, ATTLIST, NOTATION, PI, EMPTY, ANY;
%terminals ENTITY, SYSTEM, PUBLIC, PCDATA, LPAREN, PIPE, RPAREN, RPAREN_STAR, QUESTION;
%terminals STAR, PLUS, FIXED, IMPLIED, REQUIRED, COMMA, CDATA_TYPE, ID_TYPE, IDREF_TYPE;
%terminals IDREFS_TYPE, ENTITY_TYPE, ENTITIES_TYPE, NMTOKEN_TYPE, NMTOKENS_TYPE, NDATA;
%terminals NOTATION_TYPE, PE_REF, NAME, PERCENT, STRING, LBRACKET;
%terminals COMMENT, SYSTEM_LITERAL, NMTOKEN, SECTION_START, SECTION_END, IGNORE, INCLUDE;

%typeof NAME, PI, STRING = "String";

%goal DTD;

// 0

DTD
	=	Declarations.d
	{:
		return new DTDParseRootNode(d);
	:}
	|
	{:
		return new DTDParseRootNode();
	:}
	;

// 1

Declarations
	=	Declarations Declaration
	|	Declaration
	;

Declaration
	=	MarkupDecl
	|	PE_REF
	|	ConditionalSect
	;

// 2

MarkupDecl
	=	ElementDecl
	|	AttlistDecl
	|	EntityDecl
	|	NotationDecl
	|	PI.p
	{:
		String content = p.substring(2, p.length() - 2);
		
		return new DTDProcessingInstructionNode(content);
	:}
	|	COMMENT
	;

// 3

ElementDecl
	=	ELEMENT NAME.n EMPTY GREATER_THAN
	{:
		return new DTDElementDeclarationNode(n);
	:}
	|	ELEMENT NAME.n ANY GREATER_THAN
	{:
		return new DTDElementDeclarationNode(n);
	:}
	|	ELEMENT NAME.n Mixed GREATER_THAN
	{:
		return new DTDElementDeclarationNode(n);
	:}
	|	ELEMENT NAME.n Children GREATER_THAN
	{:
		return new DTDElementDeclarationNode(n);
	:}
	;

AttlistDecl
	=	ATTLIST NAME.n GREATER_THAN
	{:
		return new DTDAttributeListDeclarationNode(n);
	:}
	|	ATTLIST NAME.n AttDefs GREATER_THAN
	{:
		return new DTDAttributeListDeclarationNode(n);
	:}
	;
	
AttDefs
	=	AttDefs AttDef
	|	AttDef
	;

EntityDecl
	=	GEDecl
	|	PEDecl
	;

NotationDecl
	=	NOTATION NAME.n ExternalID GREATER_THAN
	{:
		return new DTDNotationDeclarationNode(n);
	:}
	|	NOTATION NAME.n PublicID GREATER_THAN
	{:
		return new DTDNotationDeclarationNode(n);
	:}
	;

// 4

AttDef
	=	NAME AttType DefaultDecl
	;
	
GEDecl
	=	ENTITY NAME.n STRING GREATER_THAN
	{:
		return new DTDGEntityDeclarationNode(n);
	:}
	|	ENTITY NAME.n ExternalID GREATER_THAN
	{:
		return new DTDGEntityDeclarationNode(n);
	:}
	|	ENTITY NAME.n ExternalID NDataDecl GREATER_THAN
	{:
		return new DTDGEntityDeclarationNode(n);
	:}
	;

PEDecl
	=	ENTITY PERCENT NAME.n STRING.s GREATER_THAN
	{:
		String value = s.substring(1, s.length() - 1);
		this._scanner.register(n, value);
		
		return new DTDPEntityDeclarationNode(n);
	:}
	|	ENTITY PERCENT NAME.n ExternalID GREATER_THAN
	{:
		return new DTDPEntityDeclarationNode(n);
	:}
	;

ExternalID
	=	SYSTEM SYSTEM_LITERAL
	|	PUBLIC STRING SYSTEM_LITERAL
	;

PublicID
	=	PUBLIC STRING
	;

// 5

Mixed
	=	LPAREN PCDATA RPAREN_STAR
	|	LPAREN PCDATA Names RPAREN_STAR
	|	LPAREN PCDATA RPAREN
	;
	
Names
	=	Names PIPE NAME
	|	PIPE NAME
	;

Children
	=	Choice
	|	Choice QUESTION
	|	Choice STAR
	|	Choice PLUS
	|	Seq
	|	Seq QUESTION
	|	Seq STAR
	|	Seq PLUS
	;

AttType
	=	StringType
	|	TokenizedType
	|	EnumeratedType
	;

DefaultDecl
	=	REQUIRED
	|	IMPLIED
	|	STRING
	|	FIXED STRING
	;

// 6

Choice
	=	LPAREN Cp ChoiceCps RPAREN
	;

ChoiceCps
	=	ChoiceCps PIPE Cp
	|	PIPE Cp
	;

Seq
	=	LPAREN Cp RPAREN
	|	LPAREN Cp SeqCps RPAREN
	;
	
SeqCps
	=	SeqCps COMMA Cp
	|	COMMA Cp
	;

StringType
	=	CDATA_TYPE
	;

TokenizedType
	=	ID_TYPE
	|	IDREF_TYPE
	|	IDREFS_TYPE
	|	ENTITY_TYPE
	|	ENTITIES_TYPE
	|	NMTOKEN_TYPE
	|	NMTOKENS_TYPE
	;
	
EnumeratedType
	=	NotationType
	|	Enumeration
	;
	
NDataDecl
	=	NDATA NAME
	;

// 7

Cp
	=	NAME
	|	NAME QUESTION
	|	NAME STAR
	|	NAME PLUS
	|	Choice
	|	Choice QUESTION
	|	Choice STAR
	|	Choice PLUS
	|	Seq
	|	Seq QUESTION
	|	Seq STAR
	|	Seq PLUS
	;

NotationType
	=	NOTATION_TYPE LPAREN NAME RPAREN
	|	NOTATION_TYPE LPAREN NAME Names RPAREN
	;

Enumeration
	=	LPAREN NMTOKEN RPAREN
	|	LPAREN NMTOKEN NmTokens RPAREN
	;

NmTokens
	=	NmTokens NMTOKEN
	|	NMTOKEN
	;

// misc

//ExtSubset
//	=	ExtSubsetDeclList
//	|	// nothing
//	|	TextDecl ExtSubsetDecl
//	;
	
//TextDecl
//	=	'<?xml' VersionInfo? EncodingDecl S? '?>'
//	;

//ExtSubsetDeclList
//	=	ExtSubsetDeclList ExtSubsetDecl
//	|	ExtSubsetDecl
//	;
	
//ExtSubsetDecl
//	=	MarkupDecl
//	|	ConditionalSect
//	|	PE_REF
//	;

ConditionalSect
	=	IncludeSect
	|	IgnoreSect
	;

IncludeSect
// 	=	SECTION_START INCLUDE LBRACKET ExtSubsetDecl SECTION_END
 	=	SECTION_START INCLUDE LBRACKET Declaration SECTION_END
	;

IgnoreSect
//	=	SECTION_START IGNORE LBRACKET IgnoreSectContents* SECTION_END
	=	SECTION_START IGNORE LBRACKET Declaration SECTION_END
	;

//IgnoreSectContents
//	=	Ignore (SECTION_START ignoreSectContents SECTION_END Ignore)*
//	;

//Ignore
//	=	Char* - (Char* ('<![' | ']]>') Char*)
//	;

